from mongoengine.base.datastructures import BaseList
import numpy as np
import mongoengine


class Geom(dict):
    """
    Geometric object defining a population e.g. a threshold or rectangular gate

    Parameters
    -----------
    shape: str
        Shape of the geometric object, must be one of ['ellipse', 'rect', 'threshold', '2d_threshold', 'poly', 'sml',
        'sub']
    x: str
        Name of the x-axis plane
    y: str, optional
        Name of the y-axis plane
    kwargs:
        Any additional keyword arguments
    """
    def __init__(self,
                 shape: str,
                 x: str,
                 y: str or None = None,
                 **kwargs):
        super().__init__()
        err = 'Invalid shape, must be one of: ellipse, rect, threshold, 2d_threshold', 'poly'
        assert shape in ['ellipse', 'rect', 'threshold', '2d_threshold', 'poly', 'sml', 'sub'], err
        self.shape = shape
        self.x = x
        self.y = y
        for k, v in kwargs.items():
            self[k] = v

    def as_dict(self) -> dict:
        """
        Converts object to base class (Python dictionary)

        Returns
        -------
        dict
        """
        self.update({'shape': self.shape, 'x': self.x, 'y': self.y})
        return self


def _validate_input(gate_type: str,
                    **kwargs) -> dict:
    """
    Called on init to validate input for child population definition. If valid, keyword arguments
    returned as dictionary. If invalid an assertion error is raised.

    gate_type: str
        the gate type of the intended gate to generate this child population. Must be one of:
        'threshold', 'threshold_2d', 'cluster', 'geom'.
    kwargs:
        arguments for population definition

    Returns
    --------
    dict
        True if valid else False
    """
    # Check keyword arguments
    err = f'For a {gate_type} gate child population must be defined with keys `definition` and `name`; ' \
          f'{kwargs.keys()} provided'
    if gate_type in ['threshold_1d', 'threshold_2d', 'geom']:
        assert kwargs.keys() == {'definition', 'name'}, err
    if gate_type in ['threshold_1d', 'geom']:
        definition = kwargs.get('definition')
        assert type(definition) == str, f'ChildPopulation definition should be of type str; ' \
                                        f'invalid definition {definition}'
        assert definition in ['-', '+'], f'For a threshold_1d `definition` must be one of [+, -] ' \
                                         f'not {kwargs["definition"]}'

    if gate_type == 'threshold_2d':
        definition = kwargs.get('definition')
        err = 'Invalid definition for threshold_2d, must be a string or list of strings where valid values are' \
              '[++, --, -+, +-]'
        if type(definition) == list or type(definition) == mongoengine.base.datastructures.BaseList:
            assert len(definition) > 0, err
            assert all(x in ['++', '--', '-+', '+-'] for x in definition), err
        else:
            assert definition in ['++', '--', '-+', '+-'], err

    if gate_type == 'cluster':
        assert kwargs.keys() == {'target', 'weight', 'name'}, f'For cluster gating child population must contain ' \
                                                              f'keys [target, weight, name]; {kwargs.keys()} provided'
        assert type(kwargs.get('weight')) in [float, int], 'Weight must be of type int or float'
        target = kwargs.get('target')
        err = f'Invalid target provided for child population, must be a tuple or list of values of type float or in ' \
              f'and of length 2, not {target}'
        assert len(target) == 2, err
        assert all(isinstance(x, int) or isinstance(x, float) for x in target), err
        assert isinstance(kwargs.get('weight'), int), f'Invalid data type provided for weight of child population, ' \
                                                      f'must be of type Integer'
    return kwargs


class ChildPopulation:
    def __init__(self,
                 gate_type: str,
                 **kwargs):
        """
        Representation of a single population that is to be stored in a ChildPopulationCollection. Contains the state
        of a population being generated by some gating operation.

        Parameters
        -----------
        gate_type: str
            Type of gate that generates the population
        kwargs:
            Additional keyword arguments for generating population
        """
        self.gate_type = gate_type
        self.properties = _validate_input(gate_type, **kwargs)
        self.index = np.array([])
        self.geom = None

    def update_index(self,
                     idx: np.array) -> None:
        """
        Update the index values of this population

        Parameters
        -----------
        idx: Numpy.array
            index values corresponding to events data

        Returns
        --------
        None
        """
        self.index = np.array(idx, dtype=np.int)

    def update_geom(self,
                    x: str or None,
                    shape: str or None = None,
                    y: str or None = None,
                    **kwargs):
        """
        Update geom associated to this child population instance

        Parameters
        -----------

        shape: str, optional
            type of shape generated, must be one of ['ellipse', 'rect', 'threshold', '2d_threshold', 'poly', 'sml',
            'sub']
        x: str
            name of x-axis plane
        y: str, optional
            name of y-axis plane
        kwargs:
            Other parameters that describe this geometric object

        Returns
        --------
        None
        """
        self.geom = Geom(shape, x, y, **kwargs)


class ChildPopulationCollection:
    """
    Collection of child populations. This is the standard input handed to the Gate object prior to gating. It defines
    the expected output of the operation.

    Parameters
    -----------
    gate_type: str, optional
        the gate type of the intended gate to generate this child population. Must be one of:
        ['threshold_1d', 'threshold_2d', 'cluster', 'geom', 'sml', 'sub', 'merge', None]
    json_dict: dict
        dictionary to populate ChildPopulationCollection
    """
    def __init__(self,
                 gate_type=None,
                 json_dict=None):
        self.populations = dict()
        if json_dict is not None:
            self.deserialise(json_dict)
        else:
            valid = ['threshold_1d', 'threshold_2d', 'cluster', 'geom', 'sml', 'sub', 'merge', None]
            try:
                assert gate_type in valid
                self.gate_type = gate_type
            except AssertionError:
                print(f'Invalid gate type, must be one of: {valid}')

    def serialise(self) -> dict:
        """
        Using the current properties and the populations, creates a dictionary representation
        of population data

        Returns
        -------
        dict
        """
        serialised = dict(gate_type=self.gate_type, populations=list())
        for pop in self.populations.keys():
            serialised['populations'].append(self.populations[pop].properties)
        return serialised

    def deserialise(self,
                    json_dict: dict) -> None:
        """
        Given some dictionary representation of a ChildPopulationCollection, populate the object
        with properties and populations.

        Parameters
        ----------
        json_dict: dict

        Returns
        -------
        None
        """
        self.gate_type = json_dict['gate_type']
        for pop in json_dict['populations']:
            self.add_population(**pop)

    def add_population(self,
                       name: str,
                       **kwargs) -> None:
        """
        Add a new population to this collection

        Parameters
        -----------
        name: str
            name of the population
        kwargs:
            arguments for population definition. Will differ depending on gate type:
            threshold_1d:
                - definition: one of ['+', '-']. Defines how the population is identified in
                respect to the gate's resulting threshold(s)
            threshold_2d:
                - definition: one or more of ['++', '--', '-+', '-+']. Defines how the population is identified in
                respect to the gate's resulting threshold(s)
            cluster:
                - target: 2d coordinate of expected population medoid
                - weight: integer value for populations ranked priority (used in case of merged populations)
            geom:
                - definition: one of ['+', '-']. Defines how the population is identified in respect
                to the gate's resulting geom
        :return: None
        """
        if name in self.populations.keys():
            print(f'Error: a population with name {name} has already been associated to this '
                  f'ChildPopulationCollection')
            return None
        if self.gate_type == 'threshold_1d' or self.gate_type == 'threshold_2d':
            try:
                current_definitions = list()
                for _, d in self.populations.items():
                    if type(d.properties['definition']) == list:
                        current_definitions = current_definitions + d.properties['definition']
                    else:
                        current_definitions.append(d.properties['definition'])
                if any([kwargs['definition'] == x for x in current_definitions]):
                    print(f"Error: definition {kwargs['definition']} has already been assigned to a population "
                          f"in this collection")
            except KeyError:
                print(f'Invalid input for child population construction for gate type {self.gate_type}')
        self.populations[name] = ChildPopulation(name=name, gate_type=self.gate_type, **kwargs)

    def remove_population(self, name: str) -> None:
        """
        Remove population from collection

        Parameters
        ----------
        name: str
            name of population to remove

        Returns
        --------
        None
        """
        if name not in self.populations.keys():
            print(f'Error: population {name} does not exist')
        self.populations.pop(name)

    def fetch_by_definition(self,
                            definition: str):
        """
        Given a population definition e.g. '+' or ['++', '+-'] return the name of the corresponding population

        Parameters
        ----------
        definition: str
            population definition e.g. '+' or ['++', '+-']

        Returns
        -------
        str
        """
        for name, d in self.populations.items():
            if type(d.properties['definition']) == list or type(d.properties['definition']) == BaseList:
                if definition in d.properties['definition']:
                    return name
            else:
                if definition == d.properties['definition']:
                    return name
        return None

